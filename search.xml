<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm安装robotjs报错]]></title>
    <url>%2F2019%2F05%2F17%2Fnpm%E5%AE%89%E8%A3%85robotjs%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[robotjs不支持Python 3.x 需要安装Python 2.x使用npm install或者yarn 安装依赖时，可能会出现如下类似的错误：1MSBUILD : error MSB4132: The tools version &quot;2.0&quot; is unrecognized. Available tools versions are &quot;4.0&quot;. 或者：1MSBUILD : error MSB4132: The tools version &quot;2.0&quot; is unrecognized. Available tools versions are &quot;12.0&quot;, &quot;4.0&quot;. 该类错误发生在node-gyp在构建时未能找到所需版本的构建工具，解决方法如下：12npm install --global --production windows-build-toolsnpm config set msvs_version 2015 --global 参考链接 https://www.cnblogs.com/xzysaber/p/8649228.html]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>ERR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[privacya]]></title>
    <url>%2F2019%2F04%2F23%2Fprivacya%2F</url>
    <content type="text"><![CDATA[本隐私政策介绍本公司的隐私数据相关政策和惯例，这将涵盖我们如何收集、使用、处理、存储和/或披露那些通过本公司的移动App收集的关于您的个人信息。请你仔细阅读我们的隐私政策。 一、本公司如何收集您的个人信息个人信息是可用于唯一地识别或联系某人的数据。当您使用本公司的移动App，注册用户过程中我们将会收集您的个人信息，电话号码。为了保护个人隐私，您不应提供除本公司特别要求之外的任何其它信息。 二、本公司如何使用您的个人信息1、通过您的个人信息，向您发送本公司移动App的服务信息。2、通过您的个人信息实现密码找回功能。3、除本公司发生重组、合并或出售，可将我们收集的一切个人信息转让给相关第三方外，本公司不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本公司单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些信息。 三、个人信息安全保证您的个人数据的安全对我们来说至关重要。在数据传输和数据保管两个阶段里，我们会通过广为接受的行业标准（如防火墙、加密和数据隐私法律要求）来保护您向我们提交的信息。然而，没有任何一种互联网传输或电子存储方法是100%安全的。因此，尽管我们通过商业上可接受的方式来保护您的个人信息，但仍无法保证信息的绝对安全。 四、本公司会将个人信息保存多久一般来说，本公司仅保留您的个人信息至履行收集目的所需的期限，同时将遵守适用法律规定的数据保留期限。 五、法律免责声明在法律要求的情况下，以及本公司认为必须披露与您有关的信息来保护本公司的法定权益和/或遵守司法程序、法院指令或适用于本公司的移动App的法律程序时，我们有权透露您的个人信息。如果本公司确定为了执行本公司的条款和条件或保护我们的经营，披露是合理必须的，则我们可披露与您有关的信息。 六、本隐私政策的更改如果决定更改隐私政策，我们会在本政策中、本公司网站中以及我们认为适当的位置发布这些更改，以便您了解我们如何收集、使用您的个人信息，哪些人可以访问这些信息，以及在什么情况下我们会透露这些信息。本公司保留随时修改本政策的权利，因此请经常查看。如对本政策作出重大更改，本公司会通过网站通知的形式告知。 七、隐私问题如果你对本公司的隐私政策或数据处理有任何问题或顾虑，请通过邮箱27782125@qq.com与本公司联系。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript设计模式 - 工厂模式]]></title>
    <url>%2F2019%2F04%2F03%2FJavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式（Factory Pattern）属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript设计模式]]></title>
    <url>%2F2019%2F04%2F01%2FJavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。设计模式之间的关系大致如下： 设计模式的七大原则 单一职责原则（Single Responsibility Principle）一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知识原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐私政策]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%2F</url>
    <content type="text"><![CDATA[1.使用規則 1.1用戶註冊成功後，將給予每個用戶一個用戶帳號及相應的密碼，該用戶帳號和密碼由用戶負責保管；用戶應當對以其用戶帳號進行的所有活動和事件負法律責任。 2.隱私保護 2.1保護用戶隱私是的一項基本政策，保證不對外公開或向第三方提供用戶註冊資料及用戶在使用網絡服務時存儲在的非公開內容，但下列情況除外：(a)事先獲得用戶的明確授權； (b)根據有關的法律法規要求； (c)按照相關政府主管部門的要求； (d)為維護社會公眾的利益； (e)為維護的合法權益。 2.2 可能會與第三方合作向用戶提供相關的網絡服務，在此情況下，如該第三方同意承擔與同等的保護用戶隱私的責任，則可將用戶的註冊資料等提供給該第三方。 2.3在不透露單個用戶隱私資料的前提下，有權對整個用戶數據庫進行分析並對用戶數據庫進行商業上的利用。 3.免責聲明 3.1若已經明示其網絡服務提供方式發生變更並提醒用戶應當註意事項，用戶未按要求操作所產生的一切後果由用戶自行承擔。 3.2用戶明確同意其使用網絡服務所存在的風險將完全由其自己承擔；因其使用網絡服務而產生的一切後果也由其自己承擔，對用戶不承擔任何責任。 3.3 不擔保網絡服務一定能滿足用戶的要求，也不擔保網絡服務不會中斷，對網絡服務的及時性、安全性、準確性也都不作擔保。 4.服務變更、中斷或終止 4.1如因系統維護或升級的需要而需暫停網絡服務，將盡可能事先進行通告。 4.2如發生下列任何一種情形，有權隨時中斷或終止向用戶提供本協議項下的網絡服務而無需通知用戶：(a)用戶提供的個人資料不真實； (b)用戶違反本協議中規定的使用規則。 4.3除前款所述情形外，同時保留在不事先通知用戶的情況下隨時中斷或終止部分或全部網絡服務的權利，對於所有服務的中斷或終止而造成的任何損失，無需對用戶或任何第三方承擔任何責任。 5.違約賠償 5.1用戶同意保障和維護及其他用戶的利益，如因用戶違反有關法律、法規或本協議項下的任何條款而給或任何其他第三人造成損失，用戶同意承擔由此造成的損害賠償責任。 6.修改協議 6.1 將可能不時的修改本協議的有關條款，一旦條款內容發生變動，將會在相關的頁面提示修改內容。 6.2如果不同意對服務條款所做的修改，用戶有權停止使用網絡服務。如果用戶繼續使用網絡服務，則視為用戶接受服務條款的變動。]]></content>
  </entry>
  <entry>
    <title><![CDATA[NODE中的全局对象]]></title>
    <url>%2F2019%2F03%2F26%2FNODE%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[在浏览器中全局对象是window，在Node.js中全局对象是global。所有全局变量都是全局对象的属性。 __filename__filename 表示当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径。12// app.jsconsole.log(__filename); 12E:\hexo&gt;node app.jsE:\hexo\app.js __dirname__dirname 表示当前执行脚本所在的目录。12// app.jsconsole.log(__dirname); 12E:\hexo&gt;node app.jsE:\hexo process 进程用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。 process事件beforeExit事件当 Node.js 的事件循环数组已经为空，并且没有额外的工作被添加进来，事件 ‘beforeExit’ 会被触发。 disconnect事件当 IPC 通道关闭时，会触发’disconnect’事件。 exit事件当进程准备退出时触发。两种情况下 ‘exit’ 事件会被触发： 显式调用 process.exit() 方法，使得 Node.js 进程即将结束； Node.js 事件循环数组中不再有额外的工作，使得 Node.js 进程即将结束。 exit事件监听器的回调函数，只允许包含同步操作。所有监听器的回调函数被调用后，任何在事件循环数组中排队的工作都会被强制丢弃，然后 Nodje.js 进程会立即结束。123456process.on('exit', (code) =&gt; &#123; setTimeout(() =&gt; &#123; console.log('该函数不会被执行'); &#125;, 0); console.log(`即将退出，退出码：$&#123;code&#125;`);&#125;); message事件当子进程收到父进程发送的消息时(消息通过 childprocess.send() 发送），会触发 ‘message’ 事件。 rejectionHandled事件如果有 Promise 被 rejected，并且此 Promise在 Node.js 事件循环的下次轮询及之后期间，被绑定了一个错误处理器（例如使用 promise.catch()），会触发 ‘rejectionHandled’ 事件。 uncaughtException事件如果Javascript有未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发 ‘uncaughtException’ 事件。Node.js 默认情况下会将这些异常堆栈打印到 stderr 然后进程退出。 为 ‘uncaughtException’ 事件增加监听器会覆盖上述默认行为。1234567891011process.on('uncaughtException', (err) =&gt; &#123; fs.writeSync(1, `捕获到异常：$&#123;err&#125;\n`);&#125;);setTimeout(() =&gt; &#123; console.log('这里仍然会运行。');&#125;, 500);// 故意调用一个不存在的函数，应用会抛出未捕获的异常。nonexistentFunc();console.log('这里不会运行。'); 正确使用uncaughtException事件的方式，是用它在进程结束前执行一些已分配资源（比如文件描述符，句柄等等）的同步清理操作。 触发uncaughtException事件后，用它来尝试恢复应用正常运行的操作是不安全的。想让一个已经崩溃的应用正常运行，更可靠的方式应该是启动另外一个进程来监测/探测应用是否出错， 无论uncaughtException事件是否被触发，如果监测到应用出错，则恢复或重启应用。 Signal事件当Node.js进程接收到一个信号时，会触发信号事件。例如SIGINT, SIGHUP等。 process.abort()process.abort()方法会使Node.js进程立即结束，并生成一个core文件。 process.archprocess.arch属性返回一个表示操作系统CPU架构的字符串，Node.js二进制文件是为这些架构编译的。例如：’arm’, ‘arm64’, ‘ia32’, ‘mips’, ‘mipsel’, ‘ppc’, ‘ppc64’, ‘s390’, ‘s390x’, ‘x32’, 或 ‘x64’。 process.argvprocess.argv返回一个数组，里面包含了启动Node.js进程时的命令行参数。1console.log(process.argv) 123456E:\hexo&gt;node app.js -p 80 12=333[ 'C:\\Program Files\\nodejs\\node.exe', 'E:\\hexo\\app.js', '-p', '80', '12=333' ] process.channelprocess.channel属性保存IPC channel的引用。 如果IPC channel不存在，此属性值为undefined。 process.chdir(directory)process.chdir()方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。1234567console.log(`Starting directory: $&#123;process.cwd()&#125;`);try &#123; process.chdir('/tmp'); console.log(`New directory: $&#123;process.cwd()&#125;`);&#125; catch (err) &#123; console.error(`chdir: $&#123;err&#125;`);&#125; process.configprocess.config 属性返回一个Javascript对象。此对象描述了用于编译当前Node.js执行程序时涉及的配置项信息。 这与执行./configure脚本生成的config.gypi文件结果是一样的。 process.connected只要IPC channel保持连接，process.connected属性就会返回true。 process.disconnect()被调用后，此属性会返回false。 process.cpuUsage()process.cpuUsage()方法返回包含当前进程的用户CPU时间和系统CPU时间的对象。此对象包含user和system属性，属性值的单位都是微秒(百万分之一秒)。 user和system属性值分别计算了执行用户程序和系统程序的时间。 process.cwd()process cwd() 方法返回 Node.js 进程当前工作的目录。 process.disconnect()process.disconnect()函数会关闭到父进程的IPC频道，以允许子进程一旦没有其他链接来保持活跃就优雅地关闭。调用process.disconnect()的效果和父进程调用ChildProcess.disconnect()的一样。 process.emitWarning(warning[, options])process.emitWarning()方法可用于发出定制的或应用特定的进程警告。 process.envprocess.env属性返回一个包含用户环境信息的对象。 process.execArgvprocess.execArgv 属性返回当Node.js进程被启动时，Node.js特定的命令行选项。 process.execPathprocess.execPath 属性，返回启动Node.js进程的可执行文件所在的绝对路径。 process.exit([code])process.exit()方法以结束状态码code指示Node.js同步终止进程。 process.exitCode当进程正常结束，或通过process.exit()结束但未传递参数时，此数值标识进程结束的状态码。给process.exit(code)指定一个状态码，会覆盖process.exitCode的原有值。 process.getegid()process.getegid()方法返回Node.js进程的有效数字标记的组身份。PS：这个函数只在POSIX平台有效(在Windows或Android平台无效)。 process.geteuid()process.geteuid()方法返回Node.js进程的有效数字标记的用户身份。PS：这个函数只在POSIX平台有效(在Windows或Android平台无效)。 process.getgid()process.getgid()方法返回Node.js进程的数字标记的组身份。PS：这个函数只在POSIX平台有效(在Windows或Android平台无效)。 process.getgroups()process.getgroups()方法返回数组，其中包含了补充的组ID。 如果包含有效的组ID，POSIX会将其保留为未指定状态，但 Node.js 会确保它始终处于状态。PS：这个函数只在POSIX平台有效(在Windows或Android平台无效)。 process.getuid()process.getuid()方法返回Node.js进程的数字标记的用户身份。PS：这个函数只在POSIX平台有效(在Windows或Android平台无效)。 process.kill(pid[, signal])signal | 将发送的信号，类型为string或number。默认为’SIGTERM’。process.kill()方法将signal发送给pid标识的进程。信号名称是如’SIGINT’ 或 ‘SIGHUP’的字符串。 process.mainModuleprocess.mainModule属性提供了一种获取require.main的替代方式。区别在于，若主模块在运行时中发生改变， require.main可能仍然指向变化之前所依赖的模块 一般来说，假定require.main和process.mainModule引用相同的模块是安全的。 process.memoryUsage()process.memoryUsage()方法返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。 process.nextTick(callback[, …args])process.nextTick()方法将 callback 添加到”next tick 队列”。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。这种方式不是setTimeout(fn, 0)的别名。它更加有效率。事件轮询随后的ticks 调用，会在任何I/O事件（包括定时器）之前运行。 process.pidprocess.pid属性返回进程的PID。 process.platformprocess.platform属性返回字符串，标识Node.js进程运行其上的操作系统平台。 process.ppidprocess.ppid 属性返回当前父进程的进程ID。 process.releaseprocess.release 属性返回与当前发布相关的元数据对象，包括源代码和源代码头文件 tarball的URLs。 process.send(message[, sendHandle[, options]][, callback])如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息。 接收到的消息被视为父进程的ChildProcess对象上的一个’message’事件。 process.setegid(id)id | 一个用户组名或用户组IDprocess.setegid()方法为进程设置有效的用户组ID。(请看 setegid(2).) id可以传一个数值ID或传一个用户组名称字符串。如果传了后者的话，会解析成一个相关的数值ID， 解析的时候，这个方法方法是阻塞的。PS: 这个方法只在POSIX平台可用(换句话说，Windows或Android不行)。 process.seteuid(id)id | A user name or IDprocess.seteuid()方法为进程设置有效的用户ID。(请看 seteuid(2).) id可以传一个数值ID或传一个用户名字符串。如果传了特定的用户名字符串，会解析成一个相关的数值ID， 解析的时候，这个方法方法是阻塞的。PS: 这个方法只在POSIX平台可用(换句话说，Windows或Android不行)。 process.setgid(id)id | 进程组名字或IDprocess.setgid() 为进程方法设置组ID. (查看setgid(2).) 可给id参数传一个数值ID或字符串名。如果已经有一个进程组ID名，那么在解析为相关的ID之前，此方法是阻塞。PS: 这个方法只在POSIX平台可用(换句话说，Windows或Android不行)。 process.setuid(id)process.setuid(id) 设置进程的用户ID (参见 setuid(2).) id 可以是一个数值ID也可以是一个用户名字符串. 如果已经有一个用户名，在解析为相关的数值ID时，此方法阻塞。 process.stderrprocess.stderr 属性返回连接到stderr(fd 2)的流。 它是一个net.Socket(它是一个Duplex流)，除非 fd 2指向一个文件，在这种情况下它是一个可写流。 process.stdinprocess.stdin 属性返回连接到 stdin (fd 0)的流。 它是一个net.Socket(它是一个Duplex流)，除非 fd 0指向一个文件，在这种情况下它是一个Readable流。1234567891011process.stdin.setEncoding('utf8');process.stdin.on('readable', () =&gt; &#123; const chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write(`data: $&#123;chunk&#125;`); &#125;&#125;);process.stdin.on('end', () =&gt; &#123; process.stdout.write('end');&#125;); process.stdin 返回的 Duplex 流, 可以在旧模式下使用,兼容node v0.10。 更多信息查看流的兼容性。 process.stdoutprocess.stdout 属性返回连接到 stdout (fd 1)的流。 它是一个net.Socket (它是一个Duplex流)， 除非 fd 1 指向一个文件，在这种情况下它是一个可写流。 process.titleprocess.title 属性用于获取或设置当前进程在 ps 命令中显示的进程名字。 process.umask([mask])process.umask()方法用于返回或设置Node.js进程的默认创建文件的权限掩码。 process.uptime()process.uptime() 方法返回当前 Node.js 进程运行时间秒长。 process.versionprocess.version 属性返回Node.js的版本信息。 process.versionsprocess.versions属性返回一个对象，此对象列出了Node.js和其依赖的版本信息。 Exit Codes 1 未捕获异常 - 有一个未被捕获的异常, 并且没被一个 domain 或 an ‘uncaughtException’ 事件处理器处理。 2 - 未被使用 (Bash为防内部滥用而保留) 3 内部JavaScript 分析错误 - Node.js的内部的JavaScript源代码 在引导进程中导致了一个语法分析错误。 这是非常少见的, 一般只会在开发Node.js本身的时候出现。 4 内部JavaScript执行失败 - 引导进程执行Node.js的内部的JavaScript源代码时，返回函数值失败。 这是非常少见的, 一般只会在开发Node.js本身的时候出现。 5 致命错误 - 在V8中有一个致命的错误. 比较典型的是以FATALERROR为前缀从stderr打印出来的消息。 6 非函数的内部异常处理 - 发生了一个内部异常，但是内部异常处理函数 被设置成了一个非函数，或者不能被调用。 7 内部异常处理运行时失败 - 有一个不能被捕获的异常。 在试图处理这个异常时，处理函数本身抛出了一个错误。 这是可能发生的, 比如, 如果一个 ‘uncaughtException’ 或者 domain.on(‘error’) 处理函数抛出了一个错误。 8 - 未被使用. 在之前版本的Node.js, 退出码8有时候表示一个未被捕获的异常。 9 - 不可用参数 - 也许是某个未知选项没有确定，或者没给必需要的选项填值。 10 内部JavaScript运行时失败 - 调用引导函数时， 引导进程执行Node.js的内部的JavaScript源代码抛出错误。 这是非常少见的, 一般只会在开发Node.js本身的时候出现。 12 不可用的调试参数 - –inspect 和/或 –inspect-brk 选项已设置，但选择的端口号无效或不可用。 128 退出信号 - 如果Node.js的接收信号致命诸如 SIGKILL 或 SIGHUP，那么它的退出代码将是 128 加上信号的码值。 这是POSIX的标准做法，因为退出码被定义为7位整数，并且信号退出设置高位，然后包含信号码值。 consoleconsole 用于提供控制台标准输出。Node.js 提供了与chrome浏览器行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。 Console.assert()判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。 Console.clear()清空控制台。 console.count([label])label 计数器的显示标签。 默认为 ‘default’。维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。1234567891011var user = "";function greet() &#123; console.count(); return "hi " + user;&#125;user = "bob";greet();user = "alice";greet();greet();console.count(); Console 的输出如下:1234"&lt;no label&gt;: 1""&lt;no label&gt;: 2""&lt;no label&gt;: 3""&lt;no label&gt;: 1" console.countReset()label 计数器的显示标签。 默认为 ‘default’。重置指定 label 的内部计数器。 console.error()打印一条错误信息。 console.group([…label])打印树状结构，配合groupCollapsed以及groupEnd方法; console.groupCollapsed()创建一个新的内联 group。使用方法和group相同，不同的是groupCollapsed打印出来的内容默认是折叠的。 console.groupEnd()结束当前Tree console.info()打印以感叹号字符开始的信息，使用方法和log相同 console.log()打印字符串，使用方法比较类似C的printf格式输出。 console.table()将列表型的数据打印成表格。 console.time(label)启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。 console.timeEnd(label)接受一个参数作为标识，结束特定的计时器。1234console.time('100-elements');for (let i = 0; i &lt; 100; i++) &#123;&#125;console.timeEnd('100-elements');// 打印 100-elements: 225.438ms console.trace()打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。 console.warn()打印一个警告信息，可以使用 string substitution 和额外的参数。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa笔记]]></title>
    <url>%2F2019%2F03%2F21%2FKoa%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Koa 就是一种简单好用的 Web 框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合 Unix 哲学。 基本用法架设 HTTP 服务hello world 应用1234567// server.jsconst Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 运行这个脚本。1$ node server.js 访问 http://127.0.0.1:3000 ，现在就可以看到”Hello World”了。 网页模板12345const fs = require('fs');const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./template.html');&#125;; 访问 http://127.0.0.1:3000 ，看到的就是模板文件的内容了。 路由123456789101112const koa = require('koa'), router = require('koa-router')();const app = new koa();router.get('/about', async ctx =&gt; &#123; ctx.response.body = '&lt;h1&gt;About Page&lt;/h1&gt;';&#125;);router.get('/', async ctx =&gt; &#123; ctx.response.body = '&lt;h1&gt;Index Page&lt;/h1&gt;';&#125;);app.use(router.routes());app.listen(3000, () =&gt; &#123; console.log('app started at 3000...'); &#125;); 访问 http://127.0.0.1:3000 , =&gt; Index Page访问 http://127.0.0.1:3000/about , =&gt; About Page 处理post请求router.get(‘/path’, async fn)用于处理get请求。要处理post请求，可以用router.post(‘/path’, async fn)。使用koa-bodyparser解析request的body。1234567891011121314151617181920212223242526const koa = require('koa'), bodyparser = require('koa-bodyparser'), router = require('koa-router')();const app = new koa();app.use(bodyparser());router.get('/', async (ctx, next) =&gt; &#123; ctx.response.body = `&lt;h1&gt;Index Page&lt;/h1&gt; &lt;form action="/signin" method="post"&gt; &lt;p&gt;username:&lt;input name="name" value="koa"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input name="pass" type="password"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="Submit"&gt;&lt;/p&gt; &lt;/form&gt;`;&#125;);router.post('/signin', async (ctx, next) =&gt; &#123; const name = ctx.request.body.name || '', pass = ctx.request.body.pass || ''; console.info(`signin with name: $&#123;name&#125;, password: $&#123;pass&#125;`); if (name === 'koa' &amp;&amp; pass === '123456') ctx.response.body = `&lt;h1&gt;Welcome $&#123;name&#125;&lt;/h1&gt;`; else ctx.response.body = `&lt;h1&gt;Login field!&lt;/h1&gt; &lt;p&gt;&lt;a href="/"&gt;Please try again!&lt;/a&gt; &lt;/p&gt;`;&#125;);app.use(router.routes());app.listen(3000, () =&gt; &#123; console.log('app started at 3000...'); &#125;); 模板引擎网页框架base.html123&lt;body&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/body&gt; 在app.js中编写代码12345678910111213141516171819202122232425const nunjucks = require('nunjucks'); function createEnv(path, opts) &#123; const autoescape = opts.autoescape || true, noCache = opts.noCache || false, watch = opts.watch || false, throwOnUndefined = opts.throwOnUndefined || false, env = new nunjucks.Environment( new nunjucks.FileSystemLoader('views', &#123;noCache, watch&#125;), &#123;autoescape, throwOnUndefined&#125; ); if (opts.filters) &#123; for (const f in opts.filters) &#123; env.addFilter(f, opts.filters[f]); &#125; &#125; return env; &#125; const env = createEnv('views', &#123; watch: true, filters: &#123;hex: n =&gt; &#123;return '0x' + n.toString(16);&#125;&#125; &#125;); var str = env.render('base.html', &#123;name: 'Jack'&#125;);console.log(str); $ node app.js 输出如下：1&lt;h1&gt;Jack&lt;/h1&gt;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeautifulSoup库的使用]]></title>
    <url>%2F2019%2F03%2F19%2FBeautifulSoup%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.- Beautiful Soup 4 文档 本文为学习BeautifulSoup时所做的笔记，详细内容请查看官方文档使用BeautifulSoup解析下面这段代码12345678910111213html_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;""" 通过解析得到一个BeautifulSoup 的对象，通过这个对象可以很容易的获得文档的结构化数据。123456789101112131415161718from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, 'lxml')soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.title.name# u'title'soup.title.parent.name# u'head'soup.p# &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# u'title'soup.find_all('a')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.find(id="link3")# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt; 安装 Beautiful Soup1pip install beautifulsoup4 解析器Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方解析器。主流的解析器以及它们的优缺点: table th:first-of-type { width: 130px; } 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库执行速度适中文档容错能力强 Python 2.7.3和3.2.2前的版本中文档容错能力差 lxml HTML 解析器 BeautifulSoup(markup, “lxml”) 速度快文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, [“lxml”, “xml”]) 速度快唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性以浏览器的方式解析文档生成HTML5格式的文档 速度慢不依赖外部扩展 推荐使用lxml作为解析器，因为xml效率更高。 基本用法Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种: Tag，NavigableString，BeautifulSoup，Comment。 Tag 标签Tag对象即XML或HTML原生文档中的标签。Tag对象有两个最重要的属性name和attributes12345678soup = BeautifulSoup('&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;')tag = soup.btype(tag)# &lt;class 'bs4.element.Tag'&gt;tag.name# u'b'tag['class']# u'boldest' 多值属性：最常见的多值的属性是 class (一个tag可以有多个CSS的class)，Beautiful Soup中多值属性的返回类型是list。1234567css_soup = BeautifulSoup('&lt;p class="body strikeout"&gt;&lt;/p&gt;')css_soup.p['class']# ["body", "strikeout"]css_soup = BeautifulSoup('&lt;p class="body"&gt;&lt;/p&gt;')css_soup.p['class']# ["body"] 如果某个属性看起来好像有多个值,但在任何版本的HTML定义中都没有被定义为多值属性,那么Beautiful Soup会将这个属性作为字符串返回123id_soup = BeautifulSoup('&lt;p id="my id"&gt;&lt;/p&gt;')id_soup.p['id']# 'my id 如果转换的文档是XML格式,那么tag中不包含多值属性 NavigableString 可遍历的字符串1234tag.string# u'Extremely bold'type(tag.string)# &lt;class 'bs4.element.NavigableString'&gt; NavigableString对象支持遍历文档树和搜索文档树中定义的大部分属性, 但并非全部.字符串不支持.contents或.string属性或find()方法.如果需要在Beautiful Soup之外使用NavigableString对象,需要调用unicode()方法,将该对象转换成普通的Unicode字符串,否则就算Beautiful Soup已方法已经执行结束,该对象的输出也会带有对象的引用地址.这样会浪费内存. BeautifulSoupBeautifulSoup对象表示的是一个文档的全部内容.支持遍历文档树和搜索文档树中定义的大部分功能。大部分时候,可以把它当作Tag对象,但不是真正的Tag对象，所以它没有name和attribute属性。 Comment 注释及特殊字符串Comment对象是一个特殊类型的NavigableString对象。1234567markup = "&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"soup = BeautifulSoup(markup)comment = soup.b.stringtype(comment)# &lt;class 'bs4.element.Comment'&gt;comment# u'Hey, buddy. Want to buy a used parser' 操作文档树标签选择器操作文档树最简单的方法就是告诉它你想获取的tag的name,如果想获取head标签,只要用soup.head.可以在文档树的tag中多次调用这个方法,这是个获取tag的小窍门.1234soup.head# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;soup.body.b# &lt;b&gt;The Dormouse's story&lt;/b&gt; .contents 和 .childrentag的.contents 属性可以将tag的直接子节点以列表的方式输出 tag的.children 属性可以获取tag的直接子节点的列表迭代器 1234567891011121314head_tag = soup.headhead_tag# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;head_tag.contents[&lt;title&gt;The Dormouse's story&lt;/title&gt;]title_tag = head_tag.contents[0]title_tag# &lt;title&gt;The Dormouse's story&lt;/title&gt;title_tag.contents# [u'The Dormouse's story']for child in title_tag.children: print(child) # The Dormouse's story .descendantstag的.descendants 属性可以对所有tag的子孙节点进行递归循环 1234for child in head_tag.descendants: print(child) # &lt;title&gt;The Dormouse's story&lt;/title&gt; # The Dormouse's story .string如果tag只有一个 NavigableString 类型子节点,那么这个tag可以使用 .string 得到子节点如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同如果tag包含了多个子节点,tag就无法确定 .string 方法应该调用哪个子节点的内容, .string 的输出结果是 None12345678title_tag.string# u'The Dormouse's story'head_tag.contents# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]head_tag.string# u'The Dormouse's story'print(soup.html.string)# None .strings 和 stripped_strings如果tag中包含多个字符串,可以使用 .strings 来循环获取输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容123456789101112for string in soup.stripped_strings: print(repr(string)) # u"The Dormouse's story" # u"The Dormouse's story" # u'Once upon a time there were three little sisters; and their names were' # u'Elsie' # u',' # u'Lacie' # u'and' # u'Tillie' # u';\nand they lived at the bottom of a well.' # u'...' 全部是空格的行会被忽略掉,段首和段末的空白会被删除 .parent 父节点通过 .parent 属性来获取某个元素的父节点文档的顶层节点&lt;html&gt;的父节点是 BeautifulSoup 对象BeautifulSoup 对象的 .parent 是None123456789title_tag = soup.titletitle_tag# &lt;title&gt;The Dormouse's story&lt;/title&gt;title_tag.parent# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;title_tag.string.parent# &lt;title&gt;The Dormouse's story&lt;/title&gt;print(soup.parent)# None .parents 父辈节点.parents 属性可以递归得到元素的所有父辈节点12345678910111213link = soup.alink# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;for parent in link.parents: if parent is None: print(parent) else: print(parent.name)# p# body# html# [document]# None .next_sibling 和 .previous_sibling在文档树中,使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点实际文档中的tag的 .next_sibling 和 .previous_sibling 属性通常是字符串或空白123&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt;&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt; 如果以为第一个&lt;a&gt;标签的 .next_sibling 结果是第二个&lt;a&gt;标签,那就错了,真实结果是第一个&lt;a&gt;标签和第二个&lt;a&gt;标签之间的顿号和换行符12345678link = soup.alink# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;link.next_sibling# u',\n'link.next_sibling.next_sibling# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; .next_siblings 和 .previous_siblings通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出 .next_element 和 .previous_element.next_element 属性指向解析过程中下一个被解析的对象(字符串或tag),结果可能与 .next_sibling 相同,但通常是不一样的 .next_elements 和 .previous_elements通过 .next_elements 和 .previous_elements 的迭代器就可以向前或向后访问文档的解析内容,就好像文档正在被解析一样 搜索文档树Beautiful Soup定义了很多搜索方法,find() 和 find_all()是最重要的两个,其它方法的参数和用法类似 过滤器搜索方法需要接受一个过滤器作为参数，过滤器的类型有5种:字符串,正则表达式,列表,True,方法 字符串下面的例子用于查找文档中所有的&lt;b&gt;标签12soup.find_all('b')# [&lt;b&gt;The Dormouse's story&lt;/b&gt;] 正则表达式如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到12345import refor tag in soup.find_all(re.compile("^b")): print(tag.name)# body# b 列表如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签12345soup.find_all(["a", "b"])# [&lt;b&gt;The Dormouse's story&lt;/b&gt;,# &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] TrueTrue 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点12345678910111213for tag in soup.find_all(True): print(tag.name)# html# head# title# body# p# b# p# a# a# a# p 方法如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False123456def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id')soup.find_all(has_class_but_no_id)# [&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;,# &lt;p class="story"&gt;Once upon a time there were...&lt;/p&gt;,# &lt;p class="story"&gt;...&lt;/p&gt;] find_allfind_all( name , attrs , recursive , text , **kwargs )find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件.这里有几个例子 name 参数name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉.12soup.find_all("title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 搜索 name 参数的值可以使任一类型的过滤器 keyword 参数如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性.12soup.find_all(id='link2')# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 如果传入 href 参数,Beautiful Soup会搜索每个tag的”href”属性:12soup.find_all(href=re.compile("elsie"))# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;] 搜索指定名字的属性时可以使用的参数值包括字符串, 正则表达式, 列表, True. 使用多个指定名字的参数可以同时过滤tag的多个属性:12soup.find_all(href=re.compile("elsie"), id='link1')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;three&lt;/a&gt;] 可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag:12data_soup.find_all(attrs=&#123;"data-foo": "value"&#125;)# [&lt;div data-foo="value"&gt;foo!&lt;/div&gt;] 按CSS搜索按照CSS类名搜索tag的功能非常实用,但标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tagclass_ 参数同样接受上面的5种过滤器tag的 class 属性是多值属性。按照CSS类名搜索tag时,可以分别搜索tag中的每个CSS类名123456css_soup = BeautifulSoup('&lt;p class="body strikeout"&gt;&lt;/p&gt;')css_soup.find_all("p", class_="strikeout")# [&lt;p class="body strikeout"&gt;&lt;/p&gt;]css_soup.find_all("p", class_="body")# [&lt;p class="body strikeout"&gt;&lt;/p&gt;] 搜索 class 属性时也可以通过CSS值完全匹配完全匹配 class 的值时,如果CSS类名的顺序与实际不符,将搜索不到结果 text 参数通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True12345soup.find_all(text="Elsie")# [u'Elsie']soup.find_all(text=["Tillie", "Elsie", "Lacie"])# [u'Elsie', u'Lacie', u'Tillie'] limit 参数find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量123soup.find_all("a", limit=2)# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] recursive 参数调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False12345soup.html.find_all("title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]soup.html.find_all("title", recursive=False)# [] 简写方法find_all()几乎是Beautiful Soup中最常用的搜索方法。它的简写方法是把BeautifulSoup对象和 tag对象当作一个方法来使用,这个方法的执行结果与调用这个对象的 find_all() 方法相同。下面的两种写法是等价的:12345soup.find_all("a")soup("a")soup.title.find_all(text=True)soup.title(text=True) find()find( name , attrs , recursive , text , **kwargs )使用find()方法相当于使用find_all方法并设置参数limit=1.唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果.find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None12345soup.find_all('title', limit=1)# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]soup.find('title')# &lt;title&gt;The Dormouse's story&lt;/title&gt; soup.head.title 是tag的名字方法的简写.这个简写的原理就是多次调用当前tag的find()方法12345soup.head.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.find("head").find("title")# &lt;title&gt;The Dormouse's story&lt;/title&gt; find_parents() 和 find_parent()find_all() 和 find() 只搜索当前节点的所有子节点,子孙节点等.find_parents() 和 find_parent() 用来搜索当前节点的父辈节点,搜索方法与普通tag的搜索方法相同,搜索文档搜索文档包含的内容.搜索父辈节点的方法实际上就是对 .parents 属性的迭代搜索. find_next_siblings() 和 find_next_sibling().next_siblings 属性对当tag的所有后面解析的兄弟tag节点进行迭代find_next_siblings() 方法返回所有符合条件的后面的兄弟节点find_next_sibling() 只返回符合条件的后面的第一个tag节点. find_all_next() 和 find_next().next_elements 属性对当前tag的之后的tag和字符串进行迭代find_all_next() 方法返回所有符合条件的节点find_next() 方法返回第一个符合条件的节点 find_all_previous() 和 find_previous().previous_elements 属性对当前tag的之前的tag和字符串进行迭代find_all_previous() 方法返回所有符合条件的节点find_previous() 方法返回第一个符合条件的节点 CSS选择器在Tag或BeautifulSoup对象的 .select() 方法中传入字符串参数,即可使用CSS选择器的语法找到tag12soup.select("title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 通过tag标签逐层查找12soup.select("html head title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 通过tag标签逐层查找12soup.select("html head title")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 找到兄弟节点标签123456soup.select("#link1 ~ .sister")# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.select("#link1 + .sister")# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 通过CSS的类名查找123456789soup.select(".sister")# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.select("[class~=sister]")# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过tag的id查找12345soup.select("#link1")# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]soup.select("a#link2")# [&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;] 通过是否存在某个属性来查找1234soup.select('a[href]')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;] 通过属性的值来查找12345678910111213soup.select('a[href="http://example.com/elsie"]')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;]soup.select('a[href^="http://example.com/"]')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;,# &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.select('a[href$="tillie"]')# [&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;]soup.select('a[href*=".com/el"]')# [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;Elsie&lt;/a&gt;] 通过语言设置来查找12multilingual_soup.select('p[lang|=en]')# [&lt;p lang="en"&gt;Hello&lt;/p&gt;, 修改文档树修改tag的名称和属性,重命名一个tag12345678910111213soup = BeautifulSoup('&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;')tag = soup.btag.name = "blockquote"tag['class'] = 'verybold'tag['id'] = 1tag# &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;del tag['class']del tag['id']tag# &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt; 修改 .string给tag的 .string 属性赋值,就相当于用当前的内容替代了原来的内容1234567markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'soup = BeautifulSoup(markup)tag = soup.atag.string = "New link text."tag# &lt;a href="http://example.com/"&gt;New link text.&lt;/a&gt; append()Tag.append() 方法想tag中添加内容,就好像Python的列表的 .append() 方法1234567soup = BeautifulSoup("&lt;a&gt;Foo&lt;/a&gt;")soup.a.append("Bar")soup# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;soup.a.contents# [u'Foo', u'Bar'] BeautifulSoup.new_string() 和 .new_tag()如果想添加一段文本内容到文档中也没问题,可以调用Python的 append() 方法或调用工厂方法 BeautifulSoup.new_string()123456789soup = BeautifulSoup("&lt;b&gt;&lt;/b&gt;")tag = soup.btag.append("Hello")new_string = soup.new_string(" there")tag.append(new_string)tag# &lt;b&gt;Hello there.&lt;/b&gt;tag.contents# [u'Hello', u' there'] 如果想要创建一段注释,或 NavigableString 的任何子类,将子类作为 new_string() 方法的第二个参数传入1234567from bs4 import Commentnew_comment = soup.new_string("Nice to see you.", Comment)tag.append(new_comment)tag# &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;tag.contents# [u'Hello', u' there', u'Nice to see you.'] insert()Tag.insert() 方法与 Tag.append() 方法类似,区别是不会把新元素添加到父节点 .contents 属性的最后,而是把元素插入到指定的位置.与Python列表总的 .insert() 方法的用法下同123456789markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'soup = BeautifulSoup(markup)tag = soup.atag.insert(1, "but did not endorse ")tag# &lt;a href="http://example.com/"&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;tag.contents# [u'I linked to ', u'but did not endorse', &lt;i&gt;example.com&lt;/i&gt;] insert_before() 和 insert_after()insert_before() 方法在当前tag或文本节点前插入内容insert_after() 方法在当前tag或文本节点后插入内容 clear()Tag.clear() 方法移除当前tag的内容1234567markup = '&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'soup = BeautifulSoup(markup)tag = soup.atag.clear()tag# &lt;a href="http://example.com/"&gt;&lt;/a&gt; extract()PageElement.extract() 方法将当前tag移除文档树,并作为方法结果返回 decompose()Tag.decompose() 方法将当前节点移除文档树并完全销毁 replace_with()PageElement.replace_with() 方法移除文档树中的某段内容,并用新tag或文本节点替代它 wrap()PageElement.wrap() 方法可以对指定的tag元素进行包装 [8] ,并返回包装后的结果 unwrap()Tag.unwrap() 方法与 wrap() 方法相反.将移除tag内的所有tag标签,该方法常被用来进行标记的解包与 replace_with() 方法相同, unwrap() 方法返回被移除的tag 输出格式化输出prettify() 方法将Beautiful Soup的文档树格式化后以Unicode编码输出,每个XML/HTML标签都独占一行BeautifulSoup 对象和它的tag节点都可以调用 prettify() 方法1234567print(soup.a.prettify())# &lt;a href="http://example.com/"&gt;# I linked to# &lt;i&gt;# example.com# &lt;/i&gt;# &lt;/a&gt; 压缩输出如果只想得到结果字符串,不重视格式,那么可以对一个 BeautifulSoup 对象或 Tag 对象使用Python的 unicode() 或 str() 方法str() 方法返回UTF-8编码的字符串,可以指定 编码 的设置还可以调用 encode() 方法获得字节码或调用 decode() 方法获得Unicode12345str(soup)# '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'unicode(soup.a)# u'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;' 输出格式Beautiful Soup输出是会将HTML中的特殊字符转换成Unicode,比如“&lquot;”如果将文档转换成字符串,Unicode编码会被编码成UTF-8.这样就无法正确显示HTML特殊字符了12345soup = BeautifulSoup("&amp;ldquo;Dammit!&amp;rdquo; he said.")unicode(soup)# u'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;'str(soup)# '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;' get_text()这个方法获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回123456markup = '&lt;a href="http://example.com/"&gt;\nI linked to &lt;i&gt;example.com&lt;/i&gt;\n&lt;/a&gt;'soup = BeautifulSoup(markup)soup.get_text()u'\nI linked to example.com\n'soup.i.get_text()u'example.com' 可以通过参数指定tag的文本内容的分隔符12# soup.get_text("|")u'\nI linked to |example.com|\n' 还可以去除获得文本内容的前后空白12# soup.get_text("|", strip=True)u'I linked to|example.com' 或者使用 .stripped_strings 生成器,获得文本列表后手动处理列表12[text for text in soup.stripped_strings]# [u'I linked to', u'example.com']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome插件开发Demo]]></title>
    <url>%2F2019%2F03%2F18%2FChrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91Demo%2F</url>
    <content type="text"><![CDATA[对于一个前端developer来说，chrome插件的开发非常简单，几个简单的文件就能轻松搞定。 插件的目录结构 1234567demo - js 页面所引用的javascript文件。 - popup.js - qrcode.min.js - icon.png 显示图标。 - manifest.json 插件的配置文件，可看作插件的“入口”。 - popup.html 弹出页面。 创建一个目录(demo)，并在目录中创建配置文件manifest.json 12345678910111213&#123; "manifest_version": 2, "name": "qrcode generator", "description": "二维码生成器", "version": "1.0", "browser_action": &#123; "default_icon": "icon.png", "default_popup": "popup.html", "default_title": "点这里生成当前页二维码！" &#125;, "content_security_policy": "script-src 'self'; object-src 'self'", "permissions": ["activeTab","tabs"]&#125; 创建弹出页面popup.html 1234567891011&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;title&gt;qrcode generator&lt;/title&gt; &lt;script type="text/javascript" src="js/qrcode.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/popup.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="width:150px; height:150px;" id="qrcode"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 创建执行脚本popup.js 123456789101112131415161718192021222324function load() &#123; window.console.info('ready.....'); // 获取到当前激活态的 tab 对象 chrome.tabs.query(&#123; "active" : true &#125;, function(tabArr) &#123; var tab = tabArr[0]; window.console.info("title=" + tab.title); window.console.info("url=" + tab.url); var qrcode = new QRCode(document.getElementById("qrcode"), &#123; width : 150, height : 150, colorDark : "#000000", colorLight : "#ffffff", correctLevel : QRCode.CorrectLevel.H &#125;); qrcode.clear(); qrcode.makeCode(tab.url); &#125;); &#125;; window.onload = load(); qrcode.min.js文件下载自davidshimjs. 验证插件是否可用 打开chrome扩展程序chrome://extensions/，选择开发者模式，选择已解压的扩展程序，选择demo目录，然后就看到插件二维码生成器已经成功加载了 打包 打开chrome扩展程序chrome://extensions/，选择开发者模式，选择打包扩展程序，如果打包失败，请根据错误提示信息修正，如果打包成功，会在与根目录同级的目录中生成CRX插件文件和PEM秘钥文件。 安装扩展程序 打开chrome扩展程序chrome://extensions/，拖拽CRX文件进入到当前页面即可完成安装。 参考链接]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
  </entry>
</search>
